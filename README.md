# OpenAPI to Axum Code Generator

A Rust workspace that converts OpenAPI specifications into fully functional Axum server code. This tool automatically generates Rust data structures, route handlers, and API endpoints from your OpenAPI specs.

## Project Structure

```
openapi-to-axum/
â”œâ”€â”€ Cargo.toml              # Workspace configuration
â”œâ”€â”€ openapi-parser/         # OpenAPI spec parsing library
â”œâ”€â”€ code-generator/         # Rust code generation logic
â”œâ”€â”€ cli/                    # Command-line interface
â””â”€â”€ examples/               # Sample OpenAPI specifications
```

## Prerequisites

- Rust 1.70+ and Cargo
- OpenAPI 3.0+ specification files (YAML or JSON)

## Quick Start

### 1. Clone and Build

```bash
# Clone the repository
git clone
cd openapi-to-axum

# Build the project
cargo build
```

### 2. Run with Example

```bash
# Generate code from the example Petstore API
cargo run -- -i examples/petstore.yaml -o ./output
```

This will generate `generated.rs` in your current directory.

## Usage

### Basic Usage

```bash
# Generate from YAML file (outputs to ./generated.rs)
cargo run -- -i examples/petstore.yaml -o ./output
```

## What Gets Generated

For each OpenAPI specification, the tool generates:

- **Data Structures**: Rust structs with Serde derives for all schema definitions
- **Route Handlers**: Async handler functions for each API endpoint
- **Router Setup**: Complete Axum router with all routes configured
- **Server Boilerplate**: Ready-to-use server startup code
- **Type Safety**: Proper Rust types matching your API specification

### Example Output

Given a simple OpenAPI spec with a `Pet` schema and `/pets` endpoint, you get:

```rust
//! Auto-generated Axum server from OpenAPI specification
//! Generated by openapi-to-axum
use axum::{
    routing::{get, post},
    Router, Json, extract::Path,
};
use serde::{Deserialize, Serialize};
use std::net::SocketAddr;
#[derive(Debug, Deserialize, Serialize)]
pub struct Pet {
    pub id: i64,
    pub name: String,
    pub tag: Option<String>,
}
#[derive(Debug, Deserialize, Serialize)]
pub struct NewPet {
    pub name: String,
    pub tag: Option<String>,
}
async fn handle_get__pets() -> Json<Vec<Pet>> {
    todo!("Implement {} {}", "get", "/pets")
}
async fn handle_post__pets() -> Json<Pet> {
    todo!("Implement {} {}", "post", "/pets")
}
/// Create the Axum router with all generated routes
pub fn create_app() -> Router {
    Router::new()
        .route("/pets", get(handle_get__pets))
        .route("/pets", post(handle_post__pets))
}
/// Start the server on the given address
pub async fn start_server(addr: SocketAddr) -> Result<(), Box<dyn std::error::Error>> {
    let app = create_app();
    println!("ðŸš€ Server starting on {}", addr);
    axum::serve(tokio::net::TcpListener::bind(addr).await?, app)
        .await
        .map_err(|e| e.into())
}

```

## Supported OpenAPI Features

- âœ… Path operations (GET, POST, PUT, DELETE)
- âœ… Component schemas and references
- âœ… Request/response bodies
- âœ… Path parameters
- âœ… Basic data types (string, integer, number, boolean, array, object)
- âœ… Optional vs required fields
- âœ… Nested objects and arrays

## Development

### Project Architecture

The workspace is organized into three main crates:

1. **openapi-parser**: Parses OpenAPI YAML/JSON into Rust structs
2. **code-generator**: Converts parsed specs into Rust token streams
3. **cli**: Command-line interface and file I/O

```

## Example Specifications

Check the `examples/` directory for sample OpenAPI specs:

- `petstore.yaml`: Simple Pet Store API
- Add your own YAML/JSON files to test
```
