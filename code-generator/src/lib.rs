use openapi_parser::OpenApiSpec;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

pub struct CodeGenerator;

impl CodeGenerator {
    pub fn generate_axum_app(spec: &OpenApiSpec) -> TokenStream {
        let structs = Self::generate_data_structures(spec);
        let (routes, handlers) = Self::generate_routes_and_handlers(spec);

        quote! {
            //! Auto-generated Axum server from OpenAPI specification
            //! Generated by openapi-to-axum

            use axum::{
                routing::{get, post, put, delete},
                Router, Json, extract::Path,
            };
            use serde::{Deserialize, Serialize};
            use std::net::SocketAddr;

            #structs

            #handlers

            /// Create the Axum router with all generated routes
            pub fn create_app() -> Router {
                Router::new()
                    #routes
            }

            /// Start the server on the given address
            pub async fn start_server(addr: SocketAddr) -> Result<(), Box<dyn std::error::Error>> {
                let app = create_app();

                println!("ðŸš€ Server starting on {}", addr);
                axum::serve(tokio::net::TcpListener::bind(addr).await?, app)
                    .await
                    .map_err(|e| e.into())
            }
        }
    }

    fn generate_data_structures(spec: &OpenApiSpec) -> TokenStream {
        let mut output = TokenStream::new();

        if let Some(components) = &spec.components {
            for (name, schema) in &components.schemas {
                let struct_tokens = Self::schema_to_struct(name, schema, spec);
                output.extend(struct_tokens);
            }
        }

        output
    }

    fn schema_to_struct(
        name: &str,
        schema: &openapi_parser::Schema,
        spec: &OpenApiSpec,
    ) -> TokenStream {
        let struct_name = format_ident!("{}", Self::sanitize_identifier(name));

        match schema {
            // Handle allOf - merge all schemas
            openapi_parser::Schema::AllOf { all_of } => {
                let mut all_properties = Vec::new();
                let mut all_required = Vec::new();

                for sub_schema in all_of {
                    Self::collect_properties(
                        sub_schema,
                        &mut all_properties,
                        &mut all_required,
                        spec,
                    );
                }

                let fields: Vec<TokenStream> = all_properties
                    .iter()
                    .map(|(field_name, field_schema)| {
                        let field_ident =
                            format_ident!("{}", Self::sanitize_identifier(field_name));
                        let field_type = Self::schema_to_type(field_schema, spec);

                        if all_required.contains(field_name) {
                            quote! { pub #field_ident: #field_type }
                        } else {
                            quote! { pub #field_ident: Option<#field_type> }
                        }
                    })
                    .collect();

                quote! {
                    #[derive(Debug, Deserialize, Serialize)]
                    pub struct #struct_name {
                        #(#fields),*
                    }
                }
            }
            // Handle oneOf - generate enum with variants
            openapi_parser::Schema::OneOf {
                one_of,
                discriminator,
            } => {
                let variants: Vec<TokenStream> = one_of
                    .iter()
                    .enumerate()
                    .map(|(idx, variant_schema)| {
                        let variant_name = Self::get_variant_name(variant_schema, idx);
                        let variant_type = Self::schema_to_type(variant_schema, spec);

                        quote! {
                            #variant_name(#variant_type)
                        }
                    })
                    .collect();

                if let Some(disc) = discriminator {
                    let tag = &disc.property_name;
                    quote! {
                        #[derive(Debug, Deserialize, Serialize)]
                        #[serde(tag = #tag)]
                        pub enum #struct_name {
                            #(#variants),*
                        }
                    }
                } else {
                    quote! {
                        #[derive(Debug, Deserialize, Serialize)]
                        #[serde(untagged)]
                        pub enum #struct_name {
                            #(#variants),*
                        }
                    }
                }
            }
            // Handle anyOf - similar to oneOf but more permissive
            openapi_parser::Schema::AnyOf { any_of } => {
                let variants: Vec<TokenStream> = any_of
                    .iter()
                    .enumerate()
                    .map(|(idx, variant_schema)| {
                        let variant_name = Self::get_variant_name(variant_schema, idx);
                        let variant_type = Self::schema_to_type(variant_schema, spec);

                        quote! {
                            #variant_name(#variant_type)
                        }
                    })
                    .collect();

                quote! {
                    #[derive(Debug, Deserialize, Serialize)]
                    #[serde(untagged)]
                    pub enum #struct_name {
                        #(#variants),*
                    }
                }
            }
            // Handle not - use serde_json::Value with a comment
            openapi_parser::Schema::Not { .. } => {
                quote! {
                    pub type #struct_name = serde_json::Value;
                }
            }
            // Handle regular objects
            openapi_parser::Schema::Object {
                properties,
                required,
                ..
            } => {
                if let Some(props) = properties {
                    let fields: Vec<TokenStream> = props
                        .iter()
                        .map(|(field_name, field_schema)| {
                            let field_ident =
                                format_ident!("{}", Self::sanitize_identifier(field_name));
                            let field_type = Self::schema_to_type(field_schema, spec);

                            let is_required = required
                                .as_ref()
                                .map(|r| r.contains(field_name))
                                .unwrap_or(false);

                            if is_required {
                                quote! { pub #field_ident: #field_type }
                            } else {
                                quote! { pub #field_ident: Option<#field_type> }
                            }
                        })
                        .collect();

                    quote! {
                        #[derive(Debug, Deserialize, Serialize)]
                        pub struct #struct_name {
                            #(#fields),*
                        }
                    }
                } else {
                    quote! {
                        #[derive(Debug, Deserialize, Serialize)]
                        pub struct #struct_name {}
                    }
                }
            }
            // Handle references
            openapi_parser::Schema::Reference { ref_ } => {
                let type_name = ref_.split('/').last().unwrap_or("Value");
                let ident = format_ident!("{}", Self::sanitize_identifier(type_name));
                quote! {
                    pub type #struct_name = #ident;
                }
            }
            _ => {
                quote! {
                    #[derive(Debug, Deserialize, Serialize)]
                    pub struct #struct_name {}
                }
            }
        }
    }

    fn get_variant_name(schema: &openapi_parser::Schema, idx: usize) -> proc_macro2::Ident {
        match schema {
            openapi_parser::Schema::Reference { ref_ } => {
                let name = ref_.split('/').last().unwrap_or("Value");
                format_ident!("{}", Self::sanitize_identifier(name))
            }
            _ => format_ident!("Variant{}", idx),
        }
    }

    fn schema_to_type(schema: &openapi_parser::Schema, spec: &OpenApiSpec) -> TokenStream {
        match schema {
            openapi_parser::Schema::Reference { ref_ } => {
                let type_name = ref_.split('/').last().unwrap_or("Value");
                let ident = format_ident!("{}", Self::sanitize_identifier(type_name));
                quote! { #ident }
            }
            openapi_parser::Schema::AllOf { .. }
            | openapi_parser::Schema::OneOf { .. }
            | openapi_parser::Schema::AnyOf { .. } => {
                quote! { serde_json::Value }
            }
            openapi_parser::Schema::Object {
                type_,
                format,
                items,
                ..
            } => {
                if let Some(type_str) = type_ {
                    match type_str.as_str() {
                        "string" => {
                            if let Some(fmt) = format {
                                match fmt.as_str() {
                                    "uuid" => quote! { String },
                                    "date" | "date-time" => quote! { String },
                                    _ => quote! { String },
                                }
                            } else {
                                quote! { String }
                            }
                        }
                        "integer" => {
                            if let Some(fmt) = format {
                                match fmt.as_str() {
                                    "int32" => quote! { i32 },
                                    "int64" => quote! { i64 },
                                    _ => quote! { i64 },
                                }
                            } else {
                                quote! { i64 }
                            }
                        }
                        "number" => quote! { f64 },
                        "boolean" => quote! { bool },
                        "array" => {
                            if let Some(items_schema) = items {
                                let item_type = Self::schema_to_type(items_schema, spec);
                                quote! { Vec<#item_type> }
                            } else {
                                quote! { Vec<serde_json::Value> }
                            }
                        }
                        _ => quote! { serde_json::Value },
                    }
                } else {
                    quote! { serde_json::Value }
                }
            }
            openapi_parser::Schema::SimpleType { type_, format, .. } => match type_.as_str() {
                "string" => {
                    if let Some(fmt) = format {
                        match fmt.as_str() {
                            "uuid" => quote! { String },
                            "date" | "date-time" => quote! { String },
                            _ => quote! { String },
                        }
                    } else {
                        quote! { String }
                    }
                }
                "integer" => {
                    if let Some(fmt) = format {
                        match fmt.as_str() {
                            "int32" => quote! { i32 },
                            "int64" => quote! { i64 },
                            _ => quote! { i64 },
                        }
                    } else {
                        quote! { i64 }
                    }
                }
                "number" => quote! { f64 },
                "boolean" => quote! { bool },
                _ => quote! { serde_json::Value },
            },
            openapi_parser::Schema::ArrayType { items, .. } => {
                let item_type = Self::schema_to_type(items, spec);
                quote! { Vec<#item_type> }
            }
            openapi_parser::Schema::Not { .. } => {
                quote! { serde_json::Value }
            }
        }
    }

    fn resolve_schema_ref(ref_: &str, spec: &OpenApiSpec) -> Option<openapi_parser::Schema> {
        if let Some(components) = &spec.components {
            if ref_.starts_with("#/components/schemas/") {
                let schema_name = ref_.trim_start_matches("#/components/schemas/");
                return components.schemas.get(schema_name).cloned();
            }
        }
        None
    }

    fn collect_properties(
        schema: &openapi_parser::Schema,
        properties: &mut Vec<(String, openapi_parser::Schema)>,
        required: &mut Vec<String>,
        spec: &OpenApiSpec,
    ) {
        match schema {
            openapi_parser::Schema::Object {
                properties: props,
                required: req,
                ..
            } => {
                if let Some(props) = props {
                    for (name, prop_schema) in props {
                        if !properties.iter().any(|(n, _)| n == name) {
                            properties.push((name.clone(), prop_schema.clone()));
                        }
                    }
                }
                if let Some(req) = req {
                    for r in req {
                        if !required.contains(r) {
                            required.push(r.clone());
                        }
                    }
                }
            }
            openapi_parser::Schema::Reference { ref_ } => {
                if let Some(resolved) = Self::resolve_schema_ref(ref_, spec) {
                    Self::collect_properties(&resolved, properties, required, spec);
                }
            }
            openapi_parser::Schema::AllOf { all_of } => {
                for sub_schema in all_of {
                    Self::collect_properties(sub_schema, properties, required, spec);
                }
            }
            _ => {}
        }
    }

    fn generate_routes_and_handlers(spec: &OpenApiSpec) -> (TokenStream, TokenStream) {
        let mut routes = TokenStream::new();
        let mut handlers = TokenStream::new();

        for (path, path_item) in &spec.paths {
            let (path_routes, path_handlers) = Self::generate_path_routes(path, path_item, spec);
            routes.extend(path_routes);
            handlers.extend(path_handlers);
        }

        (routes, handlers)
    }

    fn generate_path_routes(
        path: &str,
        path_item: &openapi_parser::PathItem,
        spec: &OpenApiSpec,
    ) -> (TokenStream, TokenStream) {
        let mut routes = TokenStream::new();
        let mut handlers = TokenStream::new();

        if let Some(op) = &path_item.get {
            let (route, handler) = Self::generate_route("get", path, op, spec);
            routes.extend(route);
            handlers.extend(handler);
        }
        if let Some(op) = &path_item.post {
            let (route, handler) = Self::generate_route("post", path, op, spec);
            routes.extend(route);
            handlers.extend(handler);
        }
        if let Some(op) = &path_item.put {
            let (route, handler) = Self::generate_route("put", path, op, spec);
            routes.extend(route);
            handlers.extend(handler);
        }
        if let Some(op) = &path_item.delete {
            let (route, handler) = Self::generate_route("delete", path, op, spec);
            routes.extend(route);
            handlers.extend(handler);
        }

        (routes, handlers)
    }

    fn generate_route(
        method: &str,
        path: &str,
        operation: &openapi_parser::Operation,
        spec: &OpenApiSpec,
    ) -> (TokenStream, TokenStream) {
        let handler_name = if let Some(op_id) = &operation.operation_id {
            format_ident!("{}", Self::sanitize_identifier(op_id))
        } else {
            format_ident!("handle_{}_{}", method, Self::sanitize_path(path))
        };

        let method_ident = format_ident!("{}", method);
        let path_params = Self::extract_path_parameters(operation, spec);
        let request_body = Self::extract_request_body(operation, spec);
        let response_type = Self::extract_response_type(operation, spec);

        // Build handler parameters in correct order
        let mut handler_params = Vec::new();

        // Add path parameters first
        if !path_params.is_empty() {
            let path_param_names: Vec<_> = path_params
                .iter()
                .map(|(name, _)| format_ident!("{}", Self::sanitize_identifier(name)))
                .collect();

            let path_param_types: Vec<_> =
                path_params.iter().map(|(_, type_)| type_.clone()).collect();

            if path_param_names.len() == 1 {
                let name = &path_param_names[0];
                let type_ = &path_param_types[0];
                handler_params.push(quote! {
                    Path(#name): Path<#type_>
                });
            } else {
                handler_params.push(quote! {
                    Path((#(#path_param_names),*)): Path<(#(#path_param_types),*)>
                });
            }
        }

        // Add request body second
        if let Some(body_type) = request_body.clone() {
            handler_params.push(quote! {
                Json(payload): Json<#body_type>
            });
        }

        let params_combined = if handler_params.is_empty() {
            quote! {}
        } else {
            let params = handler_params.iter();
            quote! { #(#params),* }
        };

        let route = quote! {
            .route(#path, #method_ident(#handler_name))
        };

        let handler = if let Some(return_type) = response_type {
            quote! {
                async fn #handler_name(#params_combined) -> Json<#return_type> {
                    todo!("Implement {} {}", #method, #path)
                }
            }
        } else {
            quote! {
                async fn #handler_name(#params_combined) -> Json<serde_json::Value> {
                    todo!("Implement {} {}", #method, #path)
                }
            }
        };

        (route, handler)
    }

    fn extract_path_parameters(
        operation: &openapi_parser::Operation,
        spec: &OpenApiSpec,
    ) -> Vec<(String, TokenStream)> {
        let mut params = Vec::new();

        if let Some(parameters) = &operation.parameters {
            for param in parameters {
                if param.in_ == "path" {
                    let param_type = if let Some(schema) = &param.schema {
                        Self::schema_to_type(schema, spec)
                    } else {
                        quote! { String }
                    };
                    params.push((param.name.clone(), param_type));
                }
            }
        }

        params
    }

    fn extract_request_body(
        operation: &openapi_parser::Operation,
        spec: &OpenApiSpec,
    ) -> Option<TokenStream> {
        eprintln!("DEBUG: Checking request body for operation");
        if let Some(request_body) = &operation.request_body {
            eprintln!("DEBUG: Found request_body");
            if let Some(media_type) = request_body.content.get("application/json") {
                eprintln!("DEBUG: Found application/json media type");
                if let Some(schema) = &media_type.schema {
                    eprintln!("DEBUG: Found schema, converting to type");
                    let schema_type = Self::schema_to_type(schema, spec);
                    return Some(schema_type);
                }
            }
        }
        eprintln!("DEBUG: No request body found");
        None
    }

    fn extract_response_type(
        operation: &openapi_parser::Operation,
        spec: &OpenApiSpec,
    ) -> Option<TokenStream> {
        for (status, response) in &operation.responses {
            if status.starts_with('2') {
                if let Some(content) = &response.content {
                    if let Some(media_type) = content.get("application/json") {
                        if let Some(schema) = &media_type.schema {
                            return Some(Self::schema_to_type(schema, spec));
                        }
                    }
                }
            }
        }
        None
    }

    fn sanitize_identifier(ident: &str) -> String {
        ident.replace(|c: char| !c.is_alphanumeric() && c != '_', "_")
    }

    fn sanitize_path(path: &str) -> String {
        path.replace('/', "_")
            .replace(|c: char| !c.is_alphanumeric() && c != '_', "_")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use openapi_parser::{OpenApiSpec, Operation, PathItem, Response};
    use std::collections::HashMap;

    #[test]
    fn test_path_item_parsing() {
        let mut responses = HashMap::new();
        responses.insert(
            "200".to_string(),
            Response {
                description: "Success".to_string(),
                content: None,
            },
        );

        let operation = Operation {
            operation_id: Some("getTask".to_string()),
            summary: None,
            parameters: None,
            request_body: None,
            responses,
        };

        let path_item = PathItem {
            get: Some(operation),
            post: None,
            put: None,
            delete: None,
        };

        assert!(path_item.get.is_some());
    }

    fn create_test_spec() -> OpenApiSpec {
        OpenApiSpec {
            openapi: "3.0.0".to_string(),
            info: openapi_parser::Info {
                title: "Test API".to_string(),
                version: "1.0.0".to_string(),
            },
            paths: HashMap::new(),
            components: None,
        }
    }

    #[test]
    fn test_sanitize_identifier() {
        assert_eq!(CodeGenerator::sanitize_identifier("my-field"), "my_field");
        assert_eq!(CodeGenerator::sanitize_identifier("my.field"), "my_field");
        assert_eq!(
            CodeGenerator::sanitize_identifier("valid_field"),
            "valid_field"
        );
    }

    #[test]
    fn test_sanitize_path() {
        assert_eq!(CodeGenerator::sanitize_path("/tasks"), "_tasks");
        assert_eq!(CodeGenerator::sanitize_path("/tasks/{id}"), "_tasks__id_");
        assert_eq!(
            CodeGenerator::sanitize_path("/urgent-tasks"),
            "_urgent_tasks"
        );
    }

    #[test]
    fn test_generate_axum_app() {
        let spec = create_test_spec();
        let tokens = CodeGenerator::generate_axum_app(&spec);

        // Verify tokens are not empty
        let output = tokens.to_string();
        assert!(!output.is_empty(), "Generated tokens should not be empty");

        // TokenStream output is verbose, so just check for key identifiers
        assert!(output.contains("Router"), "Should contain Router");
        assert!(
            output.contains("create_app"),
            "Should contain create_app function"
        );
        assert!(
            output.contains("start_server"),
            "Should contain start_server function"
        );
    }
}
