use openapi_parser::OpenApiSpec;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};

pub struct CodeGenerator;

impl CodeGenerator {
    pub fn generate_axum_app(spec: &OpenApiSpec) -> TokenStream {
        let structs = Self::generate_data_structures(spec);
        let (routes, handlers) = Self::generate_routes_and_handlers(spec);

        quote! {
            //! Auto-generated Axum server from OpenAPI specification
            //! Generated by openapi-to-axum

            use axum::{
                routing::{get, post},
                Router, Json, extract::Path,
            };
            use serde::{Deserialize, Serialize};
            use std::net::SocketAddr;

            #structs

            #handlers

            /// Create the Axum router with all generated routes
            pub fn create_app() -> Router {
                Router::new()
                    #routes
            }

            /// Start the server on the given address
            pub async fn start_server(addr: SocketAddr) -> Result<(), Box<dyn std::error::Error>> {
                let app = create_app();

                println!("ðŸš€ Server starting on {}", addr);
                axum::serve(tokio::net::TcpListener::bind(addr).await?, app)
                    .await
                    .map_err(|e| e.into())
            }
        }
    }

    fn generate_data_structures(spec: &OpenApiSpec) -> TokenStream {
        let mut output = TokenStream::new();

        if let Some(components) = &spec.components {
            for (name, schema) in &components.schemas {
                let struct_tokens = Self::schema_to_struct(name, schema);
                output.extend(struct_tokens);
            }
        }

        output
    }

    fn schema_to_struct(name: &str, schema: &openapi_parser::Schema) -> TokenStream {
        let struct_name = format_ident!("{}", Self::sanitize_identifier(name));

        match schema {
            openapi_parser::Schema::Object {
                properties,
                required,
                ..
            } => {
                if let Some(props) = properties {
                    let fields: Vec<TokenStream> = props
                        .iter()
                        .map(|(field_name, field_schema)| {
                            let field_ident =
                                format_ident!("{}", Self::sanitize_identifier(field_name));
                            let field_type = Self::schema_to_type(field_schema);

                            // Check if field is required
                            let is_required = required
                                .as_ref()
                                .map(|r| r.contains(field_name))
                                .unwrap_or(false);

                            if is_required {
                                quote! { pub #field_ident: #field_type }
                            } else {
                                quote! { pub #field_ident: Option<#field_type> }
                            }
                        })
                        .collect();

                    quote! {
                        #[derive(Debug, Deserialize, Serialize)]
                        pub struct #struct_name {
                            #(#fields),*
                        }
                    }
                } else {
                    quote! {
                        #[derive(Debug, Deserialize, Serialize)]
                        pub struct #struct_name {
                            // Empty struct for objects without properties
                        }
                    }
                }
            }
            _ => {
                // For non-object schemas, generate a simple struct
                let field_type = Self::schema_to_type(schema);
                quote! {
                    #[derive(Debug, Deserialize, Serialize)]
                    pub struct #struct_name {
                        value: #field_type
                    }
                }
            }
        }
    }

    fn schema_to_type(schema: &openapi_parser::Schema) -> TokenStream {
        match schema {
            openapi_parser::Schema::Reference { ref_ } => {
                // Extract type name from reference like "#/components/schemas/User"
                let type_name = ref_.split('/').last().unwrap_or("Value");
                let ident = format_ident!("{}", type_name);
                quote! { #ident }
            }
            openapi_parser::Schema::Object {
                type_, properties, ..
            } => {
                // If it's an object with properties, it's a custom struct
                // Otherwise, it's a generic JSON object
                if properties.is_some() {
                    quote! { serde_json::Value } // This will be handled by struct generation
                } else {
                    quote! { serde_json::Value }
                }
            }
            openapi_parser::Schema::SimpleType { type_, format } => match type_.as_str() {
                "string" => {
                    if let Some(format) = format {
                        match format.as_str() {
                            "uuid" => quote! { uuid::Uuid },
                            "date" | "date-time" => quote! { String },
                            _ => quote! { String },
                        }
                    } else {
                        quote! { String }
                    }
                }
                "integer" => {
                    if let Some(format) = format {
                        match format.as_str() {
                            "int32" => quote! { i32 },
                            "int64" => quote! { i64 },
                            _ => quote! { i64 },
                        }
                    } else {
                        quote! { i64 }
                    }
                }
                "number" => quote! { f64 },
                "boolean" => quote! { bool },
                _ => quote! { serde_json::Value },
            },
            openapi_parser::Schema::ArrayType { items, .. } => {
                let item_type = Self::schema_to_type(items);
                quote! { Vec<#item_type> }
            }
        }
    }
    fn generate_routes_and_handlers(spec: &OpenApiSpec) -> (TokenStream, TokenStream) {
        let mut routes = TokenStream::new();
        let mut handlers = TokenStream::new();

        for (path, path_item) in &spec.paths {
            let (path_routes, path_handlers) = Self::generate_path_routes(path, path_item);
            routes.extend(path_routes);
            handlers.extend(path_handlers);
        }

        (routes, handlers)
    }

    fn generate_path_routes(
        path: &str,
        path_item: &openapi_parser::PathItem,
    ) -> (TokenStream, TokenStream) {
        let mut routes = TokenStream::new();
        let mut handlers = TokenStream::new();

        if let Some(op) = &path_item.get {
            let (route, handler) = Self::generate_route("get", path, op);
            routes.extend(route);
            handlers.extend(handler);
        }
        if let Some(op) = &path_item.post {
            let (route, handler) = Self::generate_route("post", path, op);
            routes.extend(route);
            handlers.extend(handler);
        }

        (routes, handlers)
    }

    fn generate_route(
        method: &str,
        path: &str,
        operation: &openapi_parser::Operation,
    ) -> (TokenStream, TokenStream) {
        let handler_name = if let Some(op_id) = &operation.operation_id {
            format_ident!("{}", Self::sanitize_identifier(op_id))
        } else {
            format_ident!("handle_{}_{}", method, Self::sanitize_path(path))
        };

        // Convert method string to ident (remove quotes)
        let method_ident = format_ident!("{}", method);

        let route = quote! {
            .route(#path, #method_ident(#handler_name))
        };

        let handler = quote! {
            async fn #handler_name() -> &'static str {
                "Hello, World!"
            }
        };

        (route, handler)
    }

    fn sanitize_identifier(ident: &str) -> String {
        ident.replace(|c: char| !c.is_alphanumeric() && c != '_', "_")
    }

    fn sanitize_path(path: &str) -> String {
        path.replace('/', "_")
            .replace(|c: char| !c.is_alphanumeric() && c != '_', "_")
    }
}
